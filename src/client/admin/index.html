<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Dinosonic</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        @font-face {
            font-family: 'Dinofiles';
            src: url('/public/Dinofiles-font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #000;
            color: #fff;
        }

        .brand-title {
            font-family: 'Dinofiles', monospace;
        }

        .footer {
            color: #999;
            border-top: 1px solid #999;
        }

        .social-link {
            color: #999;
            transition: all 0.2s ease;
        }

        .social-link:hover {
            text-decoration: underline;
        }

        /* Button hover effects */
        .hover-effect {
            transition: all 0.2s ease-in-out;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            filter: brightness(120%);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }

        /* Container spacing fix */
        .dashboard-container {
            margin-top: 0;
            margin-bottom: 0;
        }

        .dashboard-container+.dashboard-container {
            margin-top: 1.5rem;
        }
    </style>
    <script>
        async function fetchVersion() {
            try {
                const response = await fetch('/api/version');
                const data = await response.json();
                document.getElementById('version').innerText = `Version ${data.version}`;
            } catch (error) {
                console.error('Error fetching version:', error);
            }
        }
        window.onload = fetchVersion;
    </script>
</head>

<body class="bg-black min-h-screen flex flex-col">
    <!-- Banner with branding -->
    <div class="w-full py-6 px-4 mb-8">
        <div class="max-w-4xl mx-auto flex items-center justify-between">
            <div>
                <h1 class="brand-title text-5xl mb-1">DINOSONIC</h1>
                <p class="text-blue-300">
                    A fast, lightweight music streaming server built with Deno, inspired by Subsonic.
                </p>
            </div>
            <div class="text-right">
                <div class="text-xs text-blue-400 mb-1">ADMIN PANEL</div>
                <div id="server-status" class="text-green-400">Server Online</div>
            </div>
        </div>
    </div>

    <div class="flex-grow flex flex-col items-center px-8">
        <h1 class="text-4xl mb-6">Admin Panel</h1>

        <!-- User Management (Visible to Admins Only) -->
        <div id="user-management" class="w-full max-w-2xl border border-white p-6 dashboard-container hidden">
            <h2 class="text-2xl mb-4">User Management</h2>

            <!-- Create User (Admin Only) -->
            <div id="admin-controls" class="mb-6 hidden">
                <h3 class="text-xl mb-2">Create User</h3>
                <input id="new-username" type="text" placeholder="Username"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
                <input id="new-password" type="password" placeholder="Password"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
                <button id="create-user" class="w-full bg-green-700 p-2 uppercase hover-effect">
                    Create User
                </button>
            </div>

            <!-- Users List -->
            <ul id="users-container" class="list-none"></ul>
        </div>

        <!-- Scrobbling Settings -->
        <div class="w-full max-w-2xl border border-white p-6 dashboard-container">
            <h2 class="text-2xl mb-4">LastFM Scrobbling</h2>
            <p>Status: <span id="lastfm-text" class="text-red-500">Not Linked</span></p>
            <button id="lastfm-button" class="w-full bg-white text-black p-2 uppercase mt-4 hover-effect">
                Link LastFM
            </button>
        </div>

        <div class="w-full max-w-2xl border border-white p-6 dashboard-container">
            <h2 class="text-2xl mb-4">ListenBrainz Scrobbling</h2>
            <p>Status: <span id="listenbrainz-text" class="text-red-500">Not Linked</span></p>

            <!-- This container will hold the input field and will be shown/hidden dynamically -->
            <div id="listenbrainz-input-container" class="hidden mt-4">
                <p class="text-sm mb-2">
                    Get your user token from your
                    <a href="https://listenbrainz.org/profile/" target="_blank"
                        class="underline hover:text-blue-300">ListenBrainz profile</a>.
                </p>
                <input id="listenbrainz-token-input" type="text" placeholder="Enter your ListenBrainz user token"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
            </div>

            <!-- A single, dynamic button that changes its text and function -->
            <button id="listenbrainz-button" class="w-full bg-white text-black p-2 uppercase mt-4 hover-effect">
                Link ListenBrainz
            </button>
        </div>

        <!-- Transcoding Profiles (Available to all users) -->
        <div id="transcoding-profiles-section" class="w-full max-w-2xl border border-white p-6 dashboard-container">
            <h2 class="text-2xl mb-4">Transcoding Profiles</h2>

            <!-- Create Profile (Admin Only) -->
            <div id="create-profile-section" class="mb-6">
                <h3 class="text-xl mb-2">Create Profile</h3>
                <input id="profile-name" type="text" placeholder="Profile Name"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
                <input id="profile-format" type="text" placeholder="Format (e.g., mp3, opus)"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
                <input id="profile-bitrate" type="number" placeholder="Bitrate (kbps)"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
                <input id="profile-client-match" type="text" placeholder="Client Match (regex)"
                    class="w-full p-2 mb-2 bg-inherit border border-white">
                <label class="flex items-center mb-2">
                    <input id="profile-enabled" type="checkbox" class="mr-2">
                    <span>Enabled</span>
                </label>
                <button id="create-profile" class="w-full bg-green-700 p-2 uppercase hover-effect">
                    Create Profile
                </button>
            </div>

            <!-- Profiles List -->
            <div>
                <h3 class="text-xl mb-2">Existing Profiles</h3>
                <ul id="profiles-container" class="list-none"></ul>
            </div>
        </div>

        <!-- Logout -->
        <div class="w-full max-w-2xl border border-white p-6 dashboard-container">
            <button id="logout-button" class="w-full bg-red-500 p-2 uppercase hover-effect">Logout</button>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer w-full py-4 px-8 mt-12">
        <div class="max-w-4xl mx-auto flex flex-col md:flex-row justify-between items-center">
            <div class="mb-4 md:mb-0">
                <span>&copy; 2025 Dinosonic | <span id="version">Version 0.0.0</span></span>
            </div>
            <div class="flex space-x-6">
                <a href="https://github.com/sonicdino/dinosonic" class="social-link" target="_blank">GitHub</a>
                <!-- <a href="https://dinosonic.fuge.dev" class="social-link" target="_blank">Website</a>
                <a href="https://docs.dinosonic.fuge.dev" class="social-link" target="_blank">Documentation</a> -->
            </div>
        </div>
    </footer>

    <!-- Edit User Modal -->
    <div id="edit-user-modal" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
        <div class="bg-black p-6 border border-white shadow-lg">
            <h2 class="text-xl font-bold mb-4">Edit User</h2>
            <label class="block">Username:
                <input type="text" id="edit-username" class="bg-inherit border border-white p-2 w-full">
            </label>
            <label class="block mt-2">New Password:
                <input type="password" id="edit-password" class="bg-inherit border border-white p-2 w-full">
            </label>
            <div class="mt-4">
                <h3 class="font-semibold">Permissions</h3>
                <div id="edit-permissions" class="grid grid-cols-2 gap-2 mt-2">
                    <!-- Checkboxes will be inserted here -->
                </div>
            </div>
            <div class="mt-4 flex justify-between">
                <button id="save-user" class="bg-green-500 px-4 py-2 hover-effect">Save</button>
                <button id="close-modal" class="bg-white text-black px-4 py-2 hover-effect">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Transcoding Profile Modal -->
    <div id="edit-profile-modal"
        class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
        <div class="bg-black p-6 border border-white shadow-lg w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">Edit Transcoding Profile</h2>
            <div class="mb-4">
                <label class="block mb-1">Profile Name:</label>
                <input type="text" id="edit-profile-name" class="bg-inherit border border-white p-2 w-full">
            </div>
            <div class="mb-4">
                <label class="block mb-1">Format (e.g., mp3, opus):</label>
                <input type="text" id="edit-profile-format" class="bg-inherit border border-white p-2 w-full">
            </div>
            <div class="mb-4">
                <label class="block mb-1">Bitrate (kbps):</label>
                <input type="number" id="edit-profile-bitrate" class="bg-inherit border border-white p-2 w-full">
            </div>
            <div class="mb-4">
                <label class="block mb-1">Client Match (regex):</label>
                <input type="text" id="edit-profile-client-match" class="bg-inherit border border-white p-2 w-full">
            </div>
            <div class="mb-4">
                <label class="flex items-center">
                    <input type="checkbox" id="edit-profile-enabled" class="mr-2">
                    <span>Enabled</span>
                </label>
            </div>
            <div class="mt-6 flex justify-between">
                <button id="save-profile" class="bg-green-500 px-4 py-2 hover-effect">Save</button>
                <button id="close-profile-modal" class="bg-white text-black px-4 py-2 hover-effect">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            const usersContainer = document.getElementById('users-container');
            const adminControls = document.getElementById('admin-controls');
            const createUserBtn = document.getElementById('create-user');

            // Modal Elements
            const editUserModal = document.getElementById('edit-user-modal');
            const editUsernameInput = document.getElementById('edit-username');
            const editPasswordInput = document.getElementById('edit-password');
            const editPermissionsContainer = document.getElementById('edit-permissions');
            const saveUserBtn = document.getElementById('save-user');
            const closeModalBtn = document.getElementById('close-modal');

            // Transcoding Profile Modal Elements
            const editProfileModal = document.getElementById('edit-profile-modal');
            const editProfileNameInput = document.getElementById('edit-profile-name');
            const editProfileFormatInput = document.getElementById('edit-profile-format');
            const editProfileBitrateInput = document.getElementById('edit-profile-bitrate');
            const editProfileClientMatchInput = document.getElementById('edit-profile-client-match');
            const editProfileEnabledInput = document.getElementById('edit-profile-enabled');
            const saveProfileBtn = document.getElementById('save-profile');
            const closeProfileModalBtn = document.getElementById('close-profile-modal');

            let editingUser = null; // Stores current user being edited
            let editingProfileId = null; // Stores current profile being edited

            async function checkUserPermissions() {
                const response = await fetch('/api/users');
                const data = await response.json();
                const currentUser = data.currentUser;

                if (currentUser.adminRole) {
                    document.getElementById('user-management').classList.remove('hidden');
                    document.getElementById('admin-controls').classList.remove('hidden');
                    fetchUsers();
                }
            }

            async function fetchUsers() {
                const response = await fetch('/api/users');
                const data = await response.json();
                const currentUser = data.currentUser;
                const users = data.users;

                usersContainer.innerHTML = '';

                users.forEach((user) => {
                    if (!currentUser.adminRole && user.username !== currentUser.username) return;

                    const userElement = document.createElement('li');
                    userElement.classList.add('border', 'p-4', 'mb-2');
                    userElement.innerHTML = `
                        <strong>${user.username}</strong>
                        ${currentUser.adminRole && user.username !== currentUser.username
                            ? `<button onclick="deleteUser('${user.username}')" class="bg-red-500 p-1 ml-2 hover-effect">Delete</button>`
                            : ''
                        }
                        <button onclick="openEditModal('${user.username}')" class="bg-blue-500 p-1 ml-2 hover-effect">Edit</button>
                    `;

                    usersContainer.appendChild(userElement);
                });

                if (currentUser.adminRole) {
                    adminControls.classList.remove('hidden');
                }
            }

            async function createUser() {
                const username = document.getElementById('new-username').value;
                const password = document.getElementById('new-password').value;

                if (!username || !password) {
                    alert('Username and password are required');
                    return;
                }

                await fetch('/api/users', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password }),
                });

                // Clear inputs
                document.getElementById('new-username').value = '';
                document.getElementById('new-password').value = '';

                fetchUsers();
            }

            window.deleteUser = async function (username) {
                if (confirm(`Are you sure you want to delete user ${username}?`)) {
                    await fetch(`/api/users/${username}`, { method: 'DELETE' });
                    fetchUsers();
                }
            };

            window.openEditModal = async function (username) {
                const response = await fetch(`/api/users/${username}`);
                editingUser = await response.json();

                // Fill modal inputs
                editUsernameInput.value = editingUser.username;
                editPasswordInput.value = ''; // Don't pre-fill passwords

                // Generate checkboxes for permissions
                editPermissionsContainer.innerHTML = '';
                const permissions = [
                    'adminRole',
                    'settingsRole',
                    'downloadRole',
                    'playlistRole',
                    'coverArtRole',
                    'jukeboxRole',
                    'streamRole',
                    'scrobblingEnabled',
                ];

                permissions.forEach((permission) => {
                    const isChecked = editingUser[permission] ? 'checked' : '';
                    editPermissionsContainer.innerHTML += `
                        <label class="flex items-center">
                            <input type="checkbox" id="perm-${permission}" ${isChecked} class="mr-2"> 
                            <span>${permission}</span>
                        </label>
                    `;
                });

                // Show modal
                editUserModal.classList.remove('hidden');
            };

            saveUserBtn.addEventListener('click', async () => {
                if (!editingUser) return;

                const updatedUser = {
                    username: editUsernameInput.value,
                    password: editPasswordInput.value || undefined, // Don't send password if empty
                    permissions: {
                        uploadRole: false,
                        commentRole: false,
                        podcastRole: false,
                        shareRole: false,
                    },
                };

                // Permissions that can be modified by the admin
                const editablePermissions = [
                    'adminRole',
                    'settingsRole',
                    'downloadRole',
                    'playlistRole',
                    'coverArtRole',
                    'jukeboxRole',
                    'streamRole',
                    'scrobblingEnabled',
                ];

                // Collect editable permissions from the form
                editablePermissions.forEach((permission) => {
                    updatedUser.permissions[permission] = document.getElementById(`perm-${permission}`).checked;
                });

                await fetch(`/api/users/${editingUser.username}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updatedUser),
                });

                editUserModal.classList.add('hidden');
                fetchUsers();
            });

            closeModalBtn.addEventListener('click', () => {
                editUserModal.classList.add('hidden');
            });

            createUserBtn.addEventListener('click', createUser);

            async function checkStatus() {
                const response = await fetch('/api/status', { credentials: 'include' });
                const data = await response.json();

                const lastfmText = document.getElementById('lastfm-text');
                const lastfmButton = document.getElementById('lastfm-button');
                const listenbrainzText = document.getElementById('listenbrainz-text');
                const listenbrainzInputContainer = document.getElementById('listenbrainz-input-container');
                const listenbrainzButton = document.getElementById('listenbrainz-button');
                const listenbrainzTokenInput = document.getElementById('listenbrainz-token-input');

                lastfmText.textContent = data.lastfm ? 'Linked' : 'Not Linked';
                lastfmText.classList.toggle('text-green-500', data.lastfm);
                lastfmText.classList.toggle('text-red-500', !data.lastfm);
                listenbrainzInputContainer.classList.add('hidden');
                listenbrainzButton.classList.remove('bg-red-500', 'bg-green-700');
                listenbrainzButton.classList.add('bg-white', 'text-black');

                if (data.lastFMScrobblingEnabled) {
                    lastfmButton.textContent = data.lastfm ? 'Unlink LastFM' : 'Link LastFM';
                    lastfmButton.onclick = () => {
                        if (data.lastfm && confirm('Are you sure you want to unlink your last.fm account?')) {
                            window.location.href = '/api/unlink/lastfm';
                        }

                        if (!data.lastfm) window.location.href = '/api/link/lastfm';
                    };

                    lastfmButton.disabled = false;
                    lastfmButton.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    lastfmButton.disabled = true;
                    lastfmButton.classList.add('opacity-50', 'cursor-not-allowed');
                    lastfmButton.onclick = () => alert('LastFM scrobbling is not enabled.');
                }

                if (data.listenBrainzScrobblingEnabled) {
                    if (data.listenBrainz) {
                        listenbrainzText.innerHTML = `Linked` // as <span class="text-white font-bold">${data.listenbrainzUser}</span>`;
                        listenbrainzText.classList.add('text-green-500');
                        listenbrainzText.classList.remove('text-red-500');

                        listenbrainzButton.textContent = 'Unlink ListenBrainz';
                        // listenbrainzButton.classList.add('bg-red-500');
                        // listenbrainzButton.classList.remove('bg-white', 'text-black');
                        listenbrainzButton.onclick = () => {
                            if (confirm('Are you sure you want to unlink your ListenBrainz account?')) {
                                unlinkListenBrainz();
                            }
                        };
                    } else {
                        listenbrainzText.textContent = 'Not Linked';
                        // listenbrainzText.classList.add('text-red-500');
                        listenbrainzText.classList.remove('text-green-500');

                        listenbrainzButton.textContent = 'Link ListenBrainz';
                        listenbrainzButton.onclick = showListenBrainzInput;
                    }

                    listenbrainzButton.disabled = false;
                    listenbrainzButton.classList.remove('opacity-50', 'cursor-not-allowed');

                } else {
                    listenbrainzButton.classList.add('opacity-50', 'cursor-not-allowed');
                    listenbrainzButton.disabled = true;
                    listenbrainzButton.onclick = () => alert('Scrobbling is not enabled in the server configuration.');
                }
            }

            function showListenBrainzInput() {
                // STATE: User wants to link, show the input field
                const listenbrainzInputContainer = document.getElementById('listenbrainz-input-container');
                const listenbrainzButton = document.getElementById('listenbrainz-button');

                listenbrainzInputContainer.classList.remove('hidden');
                listenbrainzButton.textContent = 'Save Token';
                listenbrainzButton.classList.add('bg-green-700');
                listenbrainzButton.classList.remove('bg-white', 'text-black');
                listenbrainzButton.onclick = saveListenBrainzToken;
            }


            async function saveListenBrainzToken() {
                const tokenInput = document.getElementById('listenbrainz-token-input');
                const token = tokenInput.value.trim();

                if (!token) {
                    alert('Please enter a ListenBrainz user token.');
                    return;
                }

                try {
                    const response = await fetch('/api/link/listenbrainz', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: token })
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        alert(`Successfully linked ListenBrainz account for user: ${result.userName}`);
                        tokenInput.value = ''; // Clear input on success
                    } else {
                        alert(`Failed to link token. Error: ${result.error || 'Invalid token or server error.'}`);
                    }
                } catch (error) {
                    alert('An error occurred while trying to save the token.');
                    console.error('Save ListenBrainz Token Error:', error);
                } finally {
                    checkStatus(); // Always refresh the UI to show the final state
                }
            }

            async function unlinkListenBrainz() {
                try {
                    await fetch('/api/unlink/listenbrainz', { method: 'GET' }); // Or POST if you prefer
                } catch (error) {
                    alert('An error occurred while trying to unlink.');
                    console.error('Unlink ListenBrainz Error:', error);
                } finally {
                    checkStatus(); // Refresh the UI after unlinking
                }
            }


            document.getElementById('logout-button').addEventListener('click', async () => {
                if (confirm(`Are you sure you want to log out?`)) {
                    await fetch('/api/logout', { method: 'POST', credentials: 'include' });
                    window.location.href = '/admin/login';
                }
            });


            document.getElementById('logout-button').addEventListener('click', async () => {
                if (confirm(`Are you sure you want to log out?`)) {
                    await fetch('/api/logout', { method: 'POST', credentials: 'include' });
                    window.location.href = '/admin/login';
                }
            });

            // Close modal when clicking outside of it
            editUserModal.addEventListener('click', function (event) {
                if (event.target === editUserModal) {
                    editUserModal.classList.add('hidden');
                }
            });

            // Transcoding Profiles Management
            async function loadTranscodingProfiles() {
                try {
                    const response = await fetch('/api/transcoding-profiles');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    const profilesContainer = document.getElementById('profiles-container');

                    profilesContainer.innerHTML = '';

                    if (data.profiles && data.profiles.length > 0) {
                        data.profiles.forEach(profile => {
                            const profileElement = document.createElement('li');
                            profileElement.classList.add('border', 'p-4', 'mb-2');
                            profileElement.innerHTML = `
                                <div class="flex justify-between items-center">
                                    <div>
                                        <strong>${profile.name}</strong> - ${profile.format || 'default'} 
                                        ${profile.bitRate ? `@ ${profile.bitRate}kbps` : ''}
                                        ${profile.enabled ? '(Enabled)' : '(Disabled)'}
                                    </div>
                                    <div>
                                        <button onclick="editProfile('${profile.id}')" class="bg-blue-500 p-1 ml-2 hover-effect">Edit</button>
                                        <button onclick="deleteProfile('${profile.id}')" class="bg-red-500 p-1 ml-2 hover-effect">Delete</button>
                                    </div>
                                </div>
                                ${profile.clientMatch ? `<div class="text-sm mt-1">Client Match: ${profile.clientMatch}</div>` : ''}
                            `;
                            profilesContainer.appendChild(profileElement);
                        });
                    } else {
                        profilesContainer.innerHTML = '<li class="p-4">No transcoding profiles found</li>';
                    }
                } catch (error) {
                    console.error('Error loading transcoding profiles:', error);
                    document.getElementById('profiles-container').innerHTML = '<li class="p-4 text-red-500">Error loading profiles</li>';
                }
            }

            async function createProfile() {
                const name = document.getElementById('profile-name').value;
                const format = document.getElementById('profile-format').value;
                const bitRate = document.getElementById('profile-bitrate').value;
                const clientMatch = document.getElementById('profile-client-match').value;
                const enabled = document.getElementById('profile-enabled').checked;

                if (!name) {
                    alert('Profile name is required');
                    return;
                }

                const profileData = {
                    name,
                    format: format || undefined,
                    bitRate: bitRate ? parseInt(bitRate) : undefined,
                    clientMatch: clientMatch || undefined,
                    enabled: enabled
                };

                try {
                    const response = await fetch('/api/transcoding-profiles', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(profileData),
                    });

                    if (response.ok) {
                        // Clear inputs
                        document.getElementById('profile-name').value = '';
                        document.getElementById('profile-format').value = '';
                        document.getElementById('profile-bitrate').value = '';
                        document.getElementById('profile-client-match').value = '';
                        document.getElementById('profile-enabled').checked = false;

                        loadTranscodingProfiles();
                    } else {
                        const errorData = await response.json();
                        alert(`Error: ${errorData.error || 'Failed to create profile'}`);
                    }
                } catch (error) {
                    console.error('Error creating profile:', error);
                    alert('Error creating profile');
                }
            }

            window.editProfile = async function (id) {
                try {
                    const response = await fetch(`/api/transcoding-profiles/${id}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    if (data.profile) {
                        // Fill the modal with profile data for editing
                        editingProfileId = id;
                        editProfileNameInput.value = data.profile.name;
                        editProfileFormatInput.value = data.profile.format || '';
                        editProfileBitrateInput.value = data.profile.bitRate || '';
                        editProfileClientMatchInput.value = data.profile.clientMatch || '';
                        editProfileEnabledInput.checked = data.profile.enabled;

                        // Show modal
                        editProfileModal.classList.remove('hidden');
                    }
                } catch (error) {
                    console.error('Error fetching profile for edit:', error);
                    alert('Error fetching profile for editing');
                }
            };

            // Save profile from modal
            saveProfileBtn.addEventListener('click', async () => {
                if (!editingProfileId) return;

                const name = editProfileNameInput.value;
                const format = editProfileFormatInput.value;
                const bitRate = editProfileBitrateInput.value;
                const clientMatch = editProfileClientMatchInput.value;
                const enabled = editProfileEnabledInput.checked;

                if (!name) {
                    alert('Profile name is required');
                    return;
                }

                const profileData = {
                    name,
                    format: format || undefined,
                    bitRate: bitRate ? parseInt(bitRate) : undefined,
                    clientMatch: clientMatch || undefined,
                    enabled: enabled
                };

                try {
                    const response = await fetch(`/api/transcoding-profiles/${editingProfileId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(profileData),
                    });

                    if (response.ok) {
                        // Clear inputs
                        editProfileNameInput.value = '';
                        editProfileFormatInput.value = '';
                        editProfileBitrateInput.value = '';
                        editProfileClientMatchInput.value = '';
                        editProfileEnabledInput.checked = false;

                        editingProfileId = null;

                        // Hide modal
                        editProfileModal.classList.add('hidden');

                        loadTranscodingProfiles();
                    } else {
                        const errorData = await response.json();
                        alert(`Error: ${errorData.error || 'Failed to update profile'}`);
                    }
                } catch (error) {
                    console.error('Error updating profile:', error);
                    alert('Error updating profile');
                }
            });

            // Close profile modal
            closeProfileModalBtn.addEventListener('click', () => {
                editProfileModal.classList.add('hidden');
                editingProfileId = null;
            });

            // Close modal when clicking outside of it
            editProfileModal.addEventListener('click', function (event) {
                if (event.target === editProfileModal) {
                    editProfileModal.classList.add('hidden');
                    editingProfileId = null;
                }
            });

            window.deleteProfile = async function (id) {
                if (confirm('Are you sure you want to delete this transcoding profile?')) {
                    try {
                        const response = await fetch(`/api/transcoding-profiles/${id}`, {
                            method: 'DELETE'
                        });

                        if (response.ok) {
                            loadTranscodingProfiles();
                        } else {
                            const errorData = await response.json();
                            alert(`Error: ${errorData.error || 'Failed to delete profile'}`);
                        }
                    } catch (error) {
                        console.error('Error deleting profile:', error);
                        alert('Error deleting profile');
                    }
                }
            };

            // Add event listeners for transcoding profiles
            document.getElementById('create-profile').addEventListener('click', createProfile);

            checkUserPermissions();
            checkStatus();

            // Load transcoding profiles for all users
            fetch('/api/users')
                .then(response => response.json())
                .then(data => {
                    const currentUser = data.currentUser;
                    document.getElementById('transcoding-profiles-section').classList.remove('hidden');
                    loadTranscodingProfiles();
                })
                .catch(error => console.error('Error checking user permissions:', error));
        });
    </script>
</body>

</html>